Option Compare Database
Option Explicit

Sub GenererDocumentationAccess()

    Dim appExcel As Object
    Dim wbk As Object
    Dim wksTables As Object
    Dim wksQueries As Object
    Dim wksReports As Object
    Dim db As DAO.Database
    Dim tblDef As DAO.TableDef
    Dim fld As DAO.Field
    Dim qDef As DAO.QueryDef
    Dim rpt As Access.Report
    Dim ctl As Access.Control
    Dim strFilePath As String
    Dim strFileName As String
    Dim i As Long
    Dim idx As DAO.Index ' Ajouté pour la gestion des index
    Dim fldIdx As DAO.Field ' Ajouté pour les champs d'index

    On Error GoTo ErrorHandler

    ' --- 1. Chemin du Fichier Excel ---
    strFileName = "Documentation_Access_" & Format(Now, "YYYYMMDD_HHMMSS") & ".xlsx"
    strFilePath = CurrentProject.Path & "\" & strFileName

    ' --- 2. Démarrer Excel et créer le classeur ---
    Set appExcel = CreateObject("Excel.Application")
    appExcel.Visible = True ' Rendre Excel visible
    Set wbk = appExcel.Workbooks.Add
    
    ' Supprimer les feuilles par défaut (sauf une)
    Do While wbk.Sheets.Count > 1
        appExcel.DisplayAlerts = False
        wbk.Sheets(2).Delete
        appExcel.DisplayAlerts = True
    Loop

    ' Renommer la première feuille existante pour les Tables
    Set wksTables = wbk.Sheets(1)
    wksTables.Name = "Tables"

    ' Ajouter des feuilles pour les Requêtes et les États
    Set wksQueries = wbk.Sheets.Add(After:=wksTables)
    wksQueries.Name = "Requêtes"
    Set wksReports = wbk.Sheets.Add(After:=wksQueries)
    wksReports.Name = "États"

    ' --- 3. En-têtes pour les Feuilles ---

    ' En-têtes Tables
    wksTables.Cells(1, 1).Value = "Nom de la Table"
    wksTables.Cells(1, 2).Value = "Nom du Champ"
    wksTables.Cells(1, 3).Value = "Type de Données"
    wksTables.Cells(1, 4).Value = "Taille du Champ"
    wksTables.Cells(1, 5).Value = "Est Clé Primaire"
    wksTables.Range("A1:E1").Font.Bold = True

    ' En-têtes Requêtes
    wksQueries.Cells(1, 1).Value = "Nom de la Requête"
    wksQueries.Cells(1, 2).Value = "SQL de la Requête"
    wksQueries.Range("A1:B1").Font.Bold = True

    ' En-têtes États
    wksReports.Cells(1, 1).Value = "Nom de l'État"
    wksReports.Cells(1, 2).Value = "Type de Contrôle"
    wksReports.Cells(1, 3).Value = "Nom du Contrôle"
    wksReports.Cells(1, 4).Value = "Source du Contrôle (Champ / Formule)"
    wksReports.Range("A1:D1").Font.Bold = True

    ' --- 4. Récupérer la base de données courante ---
    Set db = CurrentDb

    ' --- 5. Remplir les données ---
    Dim currentRow As Long

    ' Traiter les Tables
    currentRow = 2
    For Each tblDef In db.TableDefs
        ' Ignorer les tables système et temporaires
        If Left(tblDef.Name, 4) <> "MSys" And Left(tblDef.Name, 1) <> "~" And Not (tblDef.Attributes And dbHiddenObject) Then
            For Each fld In tblDef.Fields
                wksTables.Cells(currentRow, 1).Value = tblDef.Name
                wksTables.Cells(currentRow, 2).Value = fld.Name
                wksTables.Cells(currentRow, 3).Value = GetDataTypeName(fld.Type) ' Utilisation d'une fonction pour le nom du type
                wksTables.Cells(currentRow, 4).Value = IIf(fld.Type = dbText Or fld.Type = dbMemo, fld.Size, "") ' La taille n'a de sens que pour le texte/mémo
                
                ' Vérifier si le champ fait partie de la clé primaire (Nouvelle méthode)
                Dim isPrimaryKey As Boolean
                isPrimaryKey = False
                
                On Error Resume Next ' Gérer les erreurs si une table n'a pas d'index
                For Each idx In tblDef.Indexes
                    If idx.Primary Then ' Si c'est un index primaire
                        For Each fldIdx In idx.Fields
                            If fldIdx.Name = fld.Name Then
                                isPrimaryKey = True
                                Exit For ' Trouvé dans la clé primaire
                            End If
                        Next fldIdx
                    End If
                    If isPrimaryKey Then Exit For ' Inutile de chercher d'autres index
                Next idx
                On Error GoTo ErrorHandler ' Réactiver la gestion d'erreur générale
                
                wksTables.Cells(currentRow, 5).Value = IIf(isPrimaryKey, "Oui", "Non")
                
                currentRow = currentRow + 1
            Next fld
        End If
    Next tblDef
    wksTables.Columns.AutoFit

    ' Traiter les Requêtes
    currentRow = 2
    For Each qDef In db.QueryDefs
        ' Ignorer les requêtes système et temporaires
        If Left(qDef.Name, 4) <> "~sq_" And Not (qDef.Attributes And dbSystemObject) And Not (qDef.Attributes And dbHiddenObject) Then
            wksQueries.Cells(currentRow, 1).Value = qDef.Name
            wksQueries.Cells(currentRow, 2).Value = qDef.SQL
            currentRow = currentRow + 1
        End If
    Next qDef
    wksQueries.Columns.AutoFit

    ' Traiter les États
    currentRow = 2
    Dim obj As Access.Object
    For Each obj In CurrentProject.AllReports
        ' Ouvrir l'état en mode design pour accéder aux contrôles
        DoCmd.OpenReport obj.Name, acViewDesign
        Set rpt = Reports(obj.Name)

        For Each ctl In rpt.Controls
            wksReports.Cells(currentRow, 1).Value = rpt.Name
            wksReports.Cells(currentRow, 2).Value = TypeName(ctl) ' Ex: TextBox, Label, CommandButton
            wksReports.Cells(currentRow, 3).Value = ctl.Name
            
            ' Pour les contrôles ayant une source (champs liés ou calculs)
            On Error Resume Next ' Gérer les erreurs si ControlSource n'existe pas pour certains contrôles
            wksReports.Cells(currentRow, 4).Value = ctl.ControlSource
            On Error GoTo ErrorHandler ' Réactiver la gestion d'erreur générale
            
            currentRow = currentRow + 1
        Next ctl
        
        DoCmd.Close acReport, obj.Name, acSaveNo ' Fermer l'état sans sauvegarder les modifications
    Next obj
    wksReports.Columns.AutoFit

    ' --- 6. Enregistrer le fichier Excel ---
    wbk.SaveAs strFilePath, FileFormat:=xlOpenXMLWorkbook ' Spécifier le format pour .xlsx
    
    ' --- 7. Nettoyage ---
    Set fldIdx = Nothing
    Set idx = Nothing
    Set ctl = Nothing
    Set rpt = Nothing
    Set qDef = Nothing
    Set fld = Nothing
    Set tblDef = Nothing
    Set db = Nothing
    Set wksReports = Nothing
    Set wksQueries = Nothing
    Set wksTables = Nothing
    If Not wbk Is Nothing Then
        wbk.Close SaveChanges:=False
    End If
    If Not appExcel Is Nothing Then
        appExcel.Quit
    End If
    Set wbk = Nothing
    Set appExcel = Nothing

    MsgBox "Documentation générée avec succès dans : " & strFilePath, vbInformation
    Exit Sub

ErrorHandler:
    MsgBox "Une erreur est survenue : " & Err.Description & " (Numéro: " & Err.Number & ") à l'étape " & currentRow, vbCritical
    If Not wbk Is Nothing Then
        On Error Resume Next
        wbk.Close SaveChanges:=False
        On Error GoTo 0
    End If
    If Not appExcel Is Nothing Then
        On Error Resume Next
        appExcel.Quit
        On Error GoTo 0
    End If
    Set appExcel = Nothing
End Sub

' --- Nouvelle fonction pour obtenir le nom lisible du type de données ---
Function GetDataTypeName(DataType As DAO.DataTypeEnum) As String
    Select Case DataType
        Case dbBoolean: GetDataTypeName = "Oui/Non"
        Case dbByte: GetDataTypeName = "Octet"
        Case dbInteger: GetDataTypeName = "Entier"
        Case dbLong: GetDataTypeName = "Entier Long"
        Case dbCurrency: GetDataTypeName = "Monétaire"
        Case dbSingle: GetDataTypeName = "Réel Simple"
        Case dbDouble: GetDataTypeName = "Réel Double"
        Case dbDate: GetDataTypeName = "Date/Heure"
        Case dbText: GetDataTypeName = "Texte"
        Case dbLongBinary: GetDataTypeName = "Objet OLE"
        Case dbMemo: GetDataTypeName = "Mémo"
        Case dbGUID: GetDataTypeName = "ID de Réplication"
        Case dbBigInt: GetDataTypeName = "Grand Entier"
        Case dbVarChar: GetDataTypeName = "Texte long" ' Pour les versions plus récentes
        Case dbNumeric: GetDataTypeName = "Numérique"
        Case Else: GetDataTypeName = "Inconnu (" & DataType & ")"
    End Select
End Function
